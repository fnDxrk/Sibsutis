class DisjointSet: # конструктор класса
    def __init__(self, n):
        self.parent = list(range(n)) # список, в котором хранится информация о родителе каждой вершины
        self.rank = [0] * n # список, в котором хранится "ранг" (высота) дерева для каждой вершины

    def find(self, u): # находит корень множества, к которому принадлежит элемент
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v): # метод, который объединяет два множества, к которым принадлежат элементы u и v
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u != root_v: # проверяет, принадлежат ли элементы u и v к разным множествам
            if self.rank[root_u] > self.rank[root_v]:
                self.parent[root_v] = root_u
            elif self.rank[root_u] < self.rank[root_v]:
                self.parent[root_u] = root_v
            else:
                self.parent[root_v] = root_u
                self.rank[root_u] += 1

def kruskal(n, edges):
    edges.sort(key=lambda x: x[2])  # сортирует список ребер по весу
    ds = DisjointSet(n)
    mst = []
    
    for u, v, weight in edges: # перебирает все ребра
        if ds.find(u) != ds.find(v):
            ds.union(u, v)
            mst.append((u, v, weight))
    
    return mst

edges1 = [
    (0, 1, 1),
    (0, 2, 2),
    (1, 2, 1)
]
n1 = 3  # количество вершин
mst = kruskal(n1, edges1)

edges2 = [
    (0, 1, 4),
    (0, 2, 1),
    (1, 2, 2),
    (1, 3, 5),
    (2, 3, 3)
]
n2 = 4  # 4 вершины
mst2 = kruskal(n2, edges2)

print("Минимальное остовное дерево:", mst)
print("Минимальное остовное дерево 2:", mst2)

# 1. Сначала упорядочиваем все ребра по возрастанию весов.
# 2. Заводим таблицу: в левой колонке список ребер, в правой компоненты связности.
# 3. В первой строчке список ребер пустой и все компоненты связности одновершинные. 
# Берем минимальное по стоимости (по весу) ребро  включаем его в список ребер. Соответствующие две вершины объединяем в одну компоненту связности.
# 4. Берем следующее по стоимости (весу) ребро, добавляем к содержимому предыдущей строчки левого столбца; объединяем компоненты связности. 
# Если концы ребра уже принадлежат одной и той же компоненте связности, то данное ребро в состав минимального остова не включается.
# 5. Повторяем эти операции до тех пор, пока все вершины не окажутся в одной единственной компоненте связности 
# (для этого потребуется включить в состав остова ровно n-1 ребро).
