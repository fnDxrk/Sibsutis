import sys # задает максимально возможное значение

def matrix_chain_order(p):
    n = len(p) - 1  # количество матриц
    m = [[0 for _ in range(n)] for _ in range(n)] #  минимальное количество операций для умножения матриц с индекса i по индекс j
    s = [[0 for _ in range(n)] for _ in range(n)]  # позиция разбиения, которая будет использоваться для восстановления порядка умножения матриц

    for l in range(2, n+1):  # длина цепочки
        for i in range(n-l+1): # рассматривает все возможные начальные индексы i для каждой длины цепочки l
                               # j - конец цепочки матриц
            j = i + l - 1
            m[i][j] = sys.maxsize  # максимальное значение для поиска минимума
            for k in range(i, j):
                q = m[i][k] + m[k+1][j] + p[i] * p[k+1] * p[j+1] # вычисление стоимости умножения двух подцепочек
                                                                 # m[i][k] - минимальная стоимость умножения первой подцепочки
                                                                 # m[k+1][j] - минимальная стоимость умножения второй подцепочки
                                                                 # p[i]∗p[k+1]∗p[j+1] - стоимость перемножения двух результатирующих матриц
                if q < m[i][j]:  # eсли стоимость текущего разбиения q меньше значения m[i][j]
                    m[i][j] = q 
                    s[i][j] = k

    return m, s # m - минимальные значения операций для всех пар матриц
                # s - хранит информацию о том, где происходило оптимальное разбиение подцепочек

# восстанавливает оптимальный порядок умножения матриц по таблице s
def get_optimal_parens(s, i, j):
    if i == j:
        return f"A{i+1}"
    # если i != j, то функция делит задачу на две подзадачи (для левой и правой части) и рекурсивно вызывает саму себя для обеих частей 
    # в итоге порядок умножения будет представлен в виде строк с расстановкой скобок
    else:
        left = get_optimal_parens(s, i, s[i][j])
        right = get_optimal_parens(s, s[i][j] + 1, j)
        return f"({left} x {right})"

# Пример использования:
p = [10, 20, 50, 1, 100]
m, s = matrix_chain_order(p)

optimal_order = get_optimal_parens(s, 0, len(p)-2)
min_operations = m[0][len(p)-2]

print(f"Минимальное количество скалярных умножений: {min_operations}")
print(f"Оптимальный порядок умножения матриц: {optimal_order}")
# f(k,p)= (f(k,j)+ f(j+1,p)+ r_(k-1)∙r_j∙r_p ) - вычисляет минимальное количество операций для умножения матриц с i-й по j-ю
# выбираем k, такой что минимизируется количество операций
# вычисляем минимальное количество операций для перемножения всех матриц
# алгоритм имеет временную сложность O(n^3) где n — количество матриц
# и использует память O(n^2) для хранения промежуточных результатов